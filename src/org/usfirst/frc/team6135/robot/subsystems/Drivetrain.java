// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc.team6135.robot.subsystems;

import org.usfirst.frc.team6135.robot.RobotMap;
import org.usfirst.frc.team6135.robot.commands.*;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.VictorSP;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Drivetrain extends baseSubsystem {


    private final double kA=0.03;
	
	private final Encoder drivetrainLeftEncoder = RobotMap.leftEncoder;
    private final Encoder drivetrainRightEncoder = RobotMap.rightEncoder;
    private VictorSP rightDriveVictor = RobotMap.rightDriveVictor;
    private VictorSP leftDriveVictor = RobotMap.leftDriveVictor;
    public final RobotDrive robotDrive = RobotMap.robotDrive;
    public ADXRS450_Gyro gyro=RobotMap.gyro;
    public String frontSide;
    private boolean ifReversed=false;
    public Drivetrain() {
		super("Drivetrain");
		frontSide="Intake";
		ifReversed=false;
	}
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void initDefaultCommand() {
        //setDefaultCommand(new driveWithJoysticks());
    }

	@Override
	public void set(double s) {
		rightDriveVictor.set(s);
		leftDriveVictor.set(s);
	}
	public void set(double sl, double sr)
	{
		rightDriveVictor.set(sr);
		leftDriveVictor.set(sl);
	}
	
	public void reverse()
	{
		VictorSP t;
		robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, !RobotMap.lReverse);
		drivetrainRightEncoder.setReverseDirection(RobotMap.lReverse);
		RobotMap.lReverse=!RobotMap.lReverse;
		t=rightDriveVictor;
		
		robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, !RobotMap.rReverse);
		drivetrainLeftEncoder.setReverseDirection(RobotMap.rReverse);
		RobotMap.rReverse=!RobotMap.rReverse;
		rightDriveVictor=leftDriveVictor;
		leftDriveVictor=t;
		
		ifReversed=!ifReversed;
		if(ifReversed)
		{
			frontSide="Gear";
		}
		else
		{
			frontSide="Intake";
		}
	}
	public void drive_straight(double s)
	{
		robotDrive.drive(0.6, -gyro.getAngle()*kA);
	}
	@Override
	public double getRPM()
	{
		return (drivetrainLeftEncoder.getRate()+drivetrainLeftEncoder.getRate())/2;
	}
	public double getDistance()
	{
		return (drivetrainLeftEncoder.getDistance()+drivetrainLeftEncoder.getDistance())/2;
	}
	public double getLeftRPM()
	{
		return drivetrainLeftEncoder.getRate();
	}
	public double getLeftDistance()
	{
		return drivetrainLeftEncoder.getDistance();
	}
	public double getRightDistance()
	{
		return drivetrainRightEncoder.getDistance();
	}
	public double getRightRPM()
	{
		return drivetrainRightEncoder.getRate();
	}
	public void resetEncoders()
	{
		drivetrainRightEncoder.reset();
		drivetrainLeftEncoder.reset();
	}
	public void printToSmartDashboard()
	{
		//SmartDashboard.putBoolean("DriveFront", ifReversed);
		SmartDashboard.putString("Front Side", frontSide);
	}
}

